#!/usr/bin/env perl

# This file is part of the software that was used to process sequencing data 
# for A. vaga individuals L1-L11 analyzed in the manuscript 
# https://www.biorxiv.org/content/10.1101/489393v1 
#
# Copyright (c) 2018-2020, by Olga Vakhrusheva <vakh57@gmail.com>
#
# The script is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# The script is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with the software; if not, see
# http://www.gnu.org/licenses, or write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.

use strict;
use List::Util qw[min max];
use Cwd;

my ($matrix_file) = @ARGV;

unless ($matrix_file)
{
    die "\nNo fragment file was specified as input. Stopped";
}

print "\n";
print "#######################################################################################################\n";
print "Run get_conflicting_variants_indices.pl\n";
print "#######################################################################################################\n";
print "\n";

print "This script reads in a fragment file produced with the extractHAIRS command from HapCUT2.\n";
print "For each pair of variants simultaneously covered by at least one fragment*, the script extracts information on haplotypes supported by individual fragments.\n";
print "The script looks for pairs of conflicting variants - that is, variants represented by more than two haplotypes across different fragments.\n";
print "\n";
print "*A fragment corresponds to a single read or to a pair of reads generated from both ends of the same DNA fragment.\n";
print "\n";
print "The script reports two lists of conflicting variant pairs:\n";
print "1) list of all pairs of conflicting variants (irrespective of read support)\n";
print "2) list of those pairs of conflicting variants that a) are present in reads as three distinct haplotypes each supported by at least two fragments or b) are present in reads as four haplotypes irrespective of the number of fragments supporting different haplotypes\n";
print "\n";
print "For the information on the format of output files, see README.md\n";
print "#######################################################################################################\n";

### Specify output file names to report indices of conflicting variant pairs
#######################################################################################################

my $output_conflicting_haplotypes_file = "$matrix_file.conflicting.indices.txt";
my $output_conflicting_haplotypes_supported_file = "$matrix_file.conflicting.indices.supported.txt";

if (($output_conflicting_haplotypes_file eq $matrix_file) or ($output_conflicting_haplotypes_supported_file eq $matrix_file))
{
    die "Names of output files should not be identical to the name of the input file: $output_conflicting_haplotypes_file and $output_conflicting_haplotypes_supported_file vs $matrix_file. Stopped.";

}

print "\n";
print "Started\n";
system("date");
print "\n";
print "#######################################################################################################\n";
print "Input fragment file: $matrix_file\n";
print "\n";
print "Number of lines (fragments) in the input file:\n";
system("wc -l $matrix_file");


### Start processing haplotype information
#######################################################################################################

### Variable $TOTAL_READS_ANALYSED stores the total number of analyzed fragments
my $TOTAL_READS_ANALYSED = 0;

### Variable $PAIRS_IND_HAPS_HASH is a reference to a hash storing information on haplotypes present in individual fragments (reads) for each pair of variants covered by the same fragment
my $PAIRS_IND_HAPS_HASH; 

### Read input fragment file generated by extractHAIRS
### Information on the format of fragment files generated by extractHAIRS can be found at the following link:
### https://github.com/vibansal/HapCUT2/issues/40

open (MF,"$matrix_file") or die $!;

open (CONFH,">$output_conflicting_haplotypes_file") or die $!;
open (CONFHS,">$output_conflicting_haplotypes_supported_file") or die $!;

while (<MF>)
{

#######################################################################################################
### Next 8 commented lines contain textual description of the fragment file from https://github.com/vibansal/HapCUT2/issues/40
### Each line of the fragment file contains haplotype information found in a single fragment (read or a pair of reads)
### Column 1 is the number of blocks covered by the considered fragment
### A single block corresponds to a consecutive set of variants covered by the fragment
### Column 2 contains fragment id (read id or id of a pair of reads generated from two ends of the same fragment)
### Column 3 is the offset of the first block of variants covered by the fragment followed by the alleles at the variants in this block
### Column 5 is the offset of the second block of variants covered by the fragment followed by the alleles at the variants in this block
### etc.
### The last column contains qualities
### This information is from https://github.com/vibansal/HapCUT2/issues/40
#######################################################################################################

    chomp();

    $TOTAL_READS_ANALYSED++;

### Variable $NVARSTARTS_SPAN stores the number of blocks covered by the fragment
### Array variable @VARS_HAPLOTYPES_QUAL stores haplotype information contained in the read and the string with quality values
    my ($NVARSTARTS_SPAN, $READ_ID, @VARS_HAPLOTYPES_QUAL) = split/\s+/;

### Put haplotype-relevant information in a separate array
    my @VARS_HAPLOTYPES = @VARS_HAPLOTYPES_QUAL[0 .. ($#VARS_HAPLOTYPES_QUAL-1)];

### Get number of elements in the array with haplotype-relevant information
    my $DIM_VARS_HAPLOTYPES = scalar(@VARS_HAPLOTYPES);

#######################################################################################################
### The expected number of elements in the array with haplotype-relevant information is 2*number of blocks covered by the fragment
### This is because each block is expected to be represented by two elements: 
### 1) offset for the first variant in the block 
### 2) alleles found for this block of variants in the fragment
#######################################################################################################

    my $EXP_DIM_VARS_HAPLOTYPES = 2*$NVARSTARTS_SPAN;

    my $DIM_VARS_HAPLOTYPES_TWO_REMAINDER = $DIM_VARS_HAPLOTYPES % 2;

### Check that the actual number of elements in the array with haplotype-relevant information is equal to the expected one
    unless ($DIM_VARS_HAPLOTYPES == $EXP_DIM_VARS_HAPLOTYPES)
    {
	die "\nNumber of elements in the array with haplotype-relevant information is not equal to the expected number ($DIM_VARS_HAPLOTYPES vs $EXP_DIM_VARS_HAPLOTYPES).\nline: $_. Stopped.";
    }

    unless ($DIM_VARS_HAPLOTYPES_TWO_REMAINDER == 0)
    {
	die "\nNumber of elements in the array with haplotype-relevant information is not a multiple of two ($DIM_VARS_HAPLOTYPES).\nline: $_. Stopped.";
    }

### Variable $NVARS_TOT_SPAN stores the total number of variants covered by the fragment (variants included in any block are counted)
    my $NVARS_TOT_SPAN = 0;

### Array variable @ALL_VARS_INDICES stores indices of variants covered by the fragment
### Array variable @ALL_VARS_GENOTYPES stores corresponding alleles
### Index of a variant is just its index number in the VCF file supplied to extractHAIRS (not its chromosomal position!!!)
    my @ALL_VARS_INDICES;
    my @ALL_VARS_GENOTYPES;


#######################################################################################################
### The next block of code does the following:
### Parses information on variants covered by the fragment
### Puts indices of the covered variants into one array (@ALL_VARS_INDICES) 
### Puts the corresponding alleles found in the fragment into another array (@ALL_VARS_GENOTYPES)
#######################################################################################################

### Iterate over each block (consecutive set) of variants covered by the fragment
    for (my $VARIND=0;$VARIND<$DIM_VARS_HAPLOTYPES-1;$VARIND+=2)
    {

### Variable $VARSTART_NEW stores the offset for the first variant in the block
### Offset of a variant is just its index number in the VCF file supplied to extractHAIRS
	my $VARSTART_NEW = $VARS_HAPLOTYPES[$VARIND];
	my $VARSTART_NEW_HAPS = $VARS_HAPLOTYPES[$VARIND+1];

### Variable $VARSTART_NEW_NVARS_SPAN stores the total number of variants (consecutive) in the block
	my $VARSTART_NEW_NVARS_SPAN = length($VARSTART_NEW_HAPS);
	$NVARS_TOT_SPAN += $VARSTART_NEW_NVARS_SPAN;

### Iterate over all variants included in the block
	for (my $VAR_SUBIND=0;$VAR_SUBIND<$VARSTART_NEW_NVARS_SPAN;$VAR_SUBIND++)
	{

### Compute index number for the considered variant:
### For the first variant in the block, index number is equal to the block offset
### For the second variant in the block, index number is equal to the block offset incremented by 1
### For the third variant in the block, index number is equal to the block offset incremented by 2, etc.
### This is because all variants in the same block are consecutive in terms of their index numbers in the VCF file

### Variable $VAR_ABS_INDEX stores variant index number
	    my $VAR_ABS_INDEX = $VARSTART_NEW+$VAR_SUBIND;

### Variable $VAR_ABS_GENOTYPE stores the allele found in the fragment for the given variant
	    my $VAR_ABS_GENOTYPE = substr($VARSTART_NEW_HAPS,$VAR_SUBIND,1);

	    # print "VARSTART_NEW $VARSTART_NEW; VAR_SUBIND: $VAR_SUBIND -> VAR_ABS_INDEX $VAR_ABS_INDEX -> $VAR_ABS_GENOTYPE\n";

### Only biallelic variants are supposed to be present
	    unless ($VAR_ABS_GENOTYPE =~ /^[01]$/)
	    {
		die "\nUnexpected allele value: $VAR_ABS_GENOTYPE (index of the variant in the VCF file: $VAR_ABS_INDEX, line: $_). Stopped.";
	    }

	    push @ALL_VARS_INDICES,$VAR_ABS_INDEX;
	    push @ALL_VARS_GENOTYPES,$VAR_ABS_GENOTYPE;

	}

    }

    my $DIM_VAR_INDICES = scalar(@ALL_VARS_INDICES);

    unless ($DIM_VAR_INDICES == $NVARS_TOT_SPAN)
    {
	die "\nTotal number of variant indices to be analyzed is not equal to the expected number: $DIM_VAR_INDICES vs $NVARS_TOT_SPAN.\nIndices of variants covered by the read: @ALL_VARS_INDICES\nline: $_. Stopped.";
    }

    # print "\n";
    # print "$READ_ID:\n";
    # print "NVARS_TOT_SPAN: $NVARS_TOT_SPAN ($DIM_VAR_INDICES)\n";
    # print "ALL_VARS_INDICES: @ALL_VARS_INDICES\n";
    # print "ALL_VARS_GENOTYPES: @ALL_VARS_GENOTYPES\n";

### Check that the fragment covers at least two variants
    if ($NVARS_TOT_SPAN < 2)
    {
	die "\nFragment $READ_ID spans fewer than two variants: $NVARS_TOT_SPAN\nline: $_; Stopped.";
    }

#######################################################################################################
### The next block of code does the following:
### Iterates over all different pairs of variants covered by the fragment
### Extracts corresponding pairwise haplotypes present in the fragment (a pairwise haplotype can be one of these: 0-0, 0-1, 1-0, 1-1)
### Puts this haplotype information in a hash
#######################################################################################################

    for (my $pair_start=0;$pair_start<=$DIM_VAR_INDICES-2;$pair_start++)
    {
	my $pair_start_index = $ALL_VARS_INDICES[$pair_start];
	my $pair_start_genotype = $ALL_VARS_GENOTYPES[$pair_start];

	# print "pair_start: $pair_start -> $pair_start_index $pair_start_genotype\n";

	for (my $pair_end=$pair_start+1;$pair_end<=$DIM_VAR_INDICES-1;$pair_end++)
	{
	    my $pair_end_index = $ALL_VARS_INDICES[$pair_end];
	    my $pair_end_genotype = $ALL_VARS_GENOTYPES[$pair_end];

	    # print "pair_end: $pair_end -> $pair_end_index $pair_end_genotype\n";

	    unless ($pair_start_index < $pair_end_index)
	    {
		die "\nFragment $READ_ID has broken sorting of variant indices: index of the first variant in a pair $pair_start_index vs index of the second variant $pair_end_index.\nline: $_. Stopped.";
	    }

### Variable $pair_ind_string stores id for the considered pair of variants
### Id for a pair of variants is constructed by concatenating the two corresponding variant indices with a dot ('.') as a separator 
	    my $pair_ind_string = join('.', $pair_start_index, $pair_end_index);

### Variable $pair_hap_string stores a pairwise haplotype for the considered pair of variants found in the processed fragment
### A pairwise haplotype is constructed by concatenating the two corresponding alleles found at the two variants in the processed fragment
### Pairwise haplotypes can take one of the following values: 00, 01, 10, 11
	    my $pair_hap_string = join('', $pair_start_genotype, $pair_end_genotype);


### Increment the counter corresponding to the number of fragments containing this pairwise haplotype at the considered pair of variants
	    $PAIRS_IND_HAPS_HASH->{$pair_ind_string}->{$pair_hap_string}++;

	}

    
    }

}

close(MF);

print "\n";
print "#######################################################################################################\n";
print "Total number of analyzed fragments: $TOTAL_READS_ANALYSED\n";
print "#######################################################################################################\n";

#######################################################################################################
### The next block of code does the following:
### Iterates over all different pairs of variants simultaneously covered by at least one fragment
### Looks at the number of different haplotypes found for this pair of variants across different fragments
### Finds pairs of conflicting variants - that is, variants represented by more than two haplotypes found in different fragments
### Makes a list of all pairs of conflicting variants
### Makes a separate list containing only those pairs of conflicting variants that 1) are present in reads as three distinct haplotypes each supported at least by two reads or 2) are present in reads as four haplotypes irrespective of the number of reads supporting different haplotypes
#######################################################################################################

my $TOT_IND_PAIRS_CONSIDERED_KEYS = scalar(keys(%{$PAIRS_IND_HAPS_HASH}));

# my @CONFLICTING_PAIRS_KEYS=grep { scalar(keys(%{$PAIRS_IND_HAPS_HASH->{$_}}))>2;} (keys(%{$PAIRS_IND_HAPS_HASH}));
# print "\n";
# print "CONFLICTING_PAIRS_KEYS: @CONFLICTING_PAIRS_KEYS\n";

my $TOT_IND_PAIRS_CONFLICTING_KEYS = scalar( grep { scalar(keys(%{$PAIRS_IND_HAPS_HASH->{$_}})) > 2; } (keys(%{$PAIRS_IND_HAPS_HASH})) );

### Total number of analyzed pairs of variants
my $TOT_IND_PAIRS_CONSIDERED = 0;

### Total number of conflicting pairs of variants
my $TOT_IND_PAIRS_CONFLICTING = 0;

### Total number of conflicting pairs of variants present in fragments as >=3 haplotypes each supported by at least 2 fragments
my $TOT_IND_PAIRS_CONFLICTING_SUPPORTED = 0;

### Total number of conflicting pairs of variants present in fragments as >=3 haplotypes each supported by at least 2 fragments or as 4 haplotypes irrespective of the number of supporting fragments
my $TOT_IND_PAIRS_CONFLICTING_SUPPORTED_EXT = 0; 

foreach my $ABS_IND_PAIR (sort { ($a <=> $b) || ($a cmp $b) } keys(%{$PAIRS_IND_HAPS_HASH}))
{
    $TOT_IND_PAIRS_CONSIDERED++;

### Different haplotypes present in fragments for this pair of variants
    my @IND_PAIR_HAPS_FOUND = sort { ($a <=> $b) || ($PAIRS_IND_HAPS_HASH->{$ABS_IND_PAIR}->{$a} <=> $PAIRS_IND_HAPS_HASH->{$ABS_IND_PAIR}->{$b}) } keys(%{$PAIRS_IND_HAPS_HASH->{$ABS_IND_PAIR}});

### Number of different haplotypes present in fragments for this pair of variants
    my $NUMBER_IND_PAIR_HAPS_FOUND = scalar(@IND_PAIR_HAPS_FOUND);

### Process conflicting pairs of variants - those represented in fragments by >2 haplotypes
    if ($NUMBER_IND_PAIR_HAPS_FOUND > 2)
    {
	$TOT_IND_PAIRS_CONFLICTING++;

### Each haplotype is assigned with the corresponding number of supporting fragments
	my @NREADS_PAIR_HAPS_SUPPORT = map { $PAIRS_IND_HAPS_HASH->{$ABS_IND_PAIR}->{$_}; } @IND_PAIR_HAPS_FOUND;

	# print "$ABS_IND_PAIR: @IND_PAIR_HAPS_FOUND -> @NREADS_PAIR_HAPS_SUPPORT\n";

### Number of fragments supporting least frequent haplotype 
	my $MIN_HAP_READS_SUPPORT = min(@NREADS_PAIR_HAPS_SUPPORT);

	print CONFH "$ABS_IND_PAIR; $NUMBER_IND_PAIR_HAPS_FOUND; @IND_PAIR_HAPS_FOUND; @NREADS_PAIR_HAPS_SUPPORT; $MIN_HAP_READS_SUPPORT\n";

### Cases when the least frequent haplotype is supported by at least two fragments
	if ($MIN_HAP_READS_SUPPORT >= 2) 
	{
	    $TOT_IND_PAIRS_CONFLICTING_SUPPORTED++;
	}

### Cases when the least frequent haplotype is supported by at least two fragments or there are >3 different haplotypes found
	if (($MIN_HAP_READS_SUPPORT >= 2) or ($NUMBER_IND_PAIR_HAPS_FOUND > 3)) 
	{
	    $TOT_IND_PAIRS_CONFLICTING_SUPPORTED_EXT++;

	    print CONFHS "$ABS_IND_PAIR; $NUMBER_IND_PAIR_HAPS_FOUND; @IND_PAIR_HAPS_FOUND; @NREADS_PAIR_HAPS_SUPPORT; $MIN_HAP_READS_SUPPORT\n";

	}

    }

}

print "\n";
print "#######################################################################################################\n";
print "Statistics on the numbers of analyzed variant pairs:\n\n";
print "Total number of analyzed pairs of variants (those simultaneously covered by at least one fragment):\n";
print "$TOT_IND_PAIRS_CONSIDERED\n";

print "\n";
print "Total number of conflicting pairs of variants (those represented by >2 haplotypes in the aligned fragments):\n";
print "$TOT_IND_PAIRS_CONFLICTING\n";

print "\n";
print "Total number of conflicting pairs of variants (>2 haplotypes) with the least frequent haplotype supported by >=2 fragments:\n";
print "$TOT_IND_PAIRS_CONFLICTING_SUPPORTED\n";

print "\n";
print "Total number of conflicting pairs of variants (>2 haplotypes) with the least frequent haplotype supported by >=2 fragments or present as 4 different haplotypes (irrespective of fragment support):\n";
print "$TOT_IND_PAIRS_CONFLICTING_SUPPORTED_EXT\n";

close(CONFH);
close(CONFHS);

print "\n";
print "#######################################################################################################\n";
print "#######################################################################################################\n";
print "Complete list of conflicting pairs of variants (>2 haplotypes in the aligned fragments irrespective of fragment support) was written to the file:\n";
print "$output_conflicting_haplotypes_file\n";
print "\n";
print "Number of lines in the resulting file:\n";
system("wc -l $output_conflicting_haplotypes_file");
print "\n";

print "#######################################################################################################\n";
print "List of conflicting pairs of variants (>2 haplotypes) with the least frequent haplotype supported by >=2 fragments or present as 4 different haplotypes (irrespective of fragment support) was written to the file:\n";
print "$output_conflicting_haplotypes_supported_file\n";
print "\n";
print "Number of lines in the resulting file:\n";
system("wc -l $output_conflicting_haplotypes_supported_file");
print "\n";
print "#######################################################################################################\n";
print "For the information on the format of output files, see README.md\n";
print "#######################################################################################################\n";
print "#######################################################################################################\n";
print "\nFinished\n";
system("date");
